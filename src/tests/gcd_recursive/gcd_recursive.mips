.macro print_str (%str)                           # .macro print_str (%str)
    .data                                         #     .data
        string: .asciiz %str                      #         string: .asciiz %str
    .text                                         #     .text
        li $v0, 4                                 #         li $v0, 4
        la $a0, string                            #         la $a0, string
        syscall                                   #         syscall
.end_macro                                        # .end_macro
.data                                             # .data
    x:   .word 20, 9, 432, 24, 49, 339, 63        #     x:   .word 20, 9, 432, 24, 49, 339, 63
    y:   .word 5,  7, 226, 18, 7,  9,   9         #     y:   .word 5,  7, 226, 18, 7,  9,   9
    z:   .word 0,  0, 0,   0,  0,  0,   0         #     z:   .word 0,  0, 0,   0,  0,  0,   0
    len: .word 7                                  #     len: .word 7
.text                                             # .text
j main                                            # j main
# ====================
# jal call_gcd
# args:
#    $a0: a - i32
#    $a1: b - i32
# return:
#    $v0: i32
# ====================
call_gcd:                                         # fn gcd(a: i32, b: i32) i32{
    # save used s registers to stack
    subiu $sp, $sp, 4                             #     $sp = $sp[-1]
    sw $ra, 0($sp)                                #     $sp[0] = $ra
                                                  #
    move $t0 $a0                                  #     !TODO! = $a0
    move $t1 $a1                                  #     !TODO! = $a1
    # body
    bnez $t1, if_end                              #     if b == 0 {
        move $v0 $t0                              #         v      a
        j deinit_gcd                              #         return ^;
    if_end:                                       #     }
    move $a0 $t1                                  #     v               b
    rem $a1, $t0 $t1                              #     v                  a % b
    jal call_gcd                                  #     v           gcd(^, ^^^^^)
    move $v0, $v0                                 #     return$v0 = ^^^^^^^^^^^^^
                                                  #
deinit_gcd:                                       # cleanup:
    # reload used s registers from stack
    lw $ra, 0($sp)                                #     $ra = $sp[0]
    addiu $sp, $sp, 4                             #     $sp = $sp[1]
jr $ra                                            # }
                                                  #
# ====================
# jal call_equal_count
# args:
#    $a0: bArray - [*]i32
#    $a1: cArray - [*]i32
#    $a2: len - i32
# return:
#    $v0: i32
# ====================
call_equal_count:                                 # fn equal_count(bArray: [*]i32, cArray: [*]i32, len: i32) i32{
    # save used s registers to stack
    subiu $sp, $sp, 4                             #     $sp = $sp[-1]
    sw $ra, 0($sp)                                #     $sp[0] = $ra
                                                  #
    # body
    move $t0 $zero                                #     count = 0
    move $t1 $zero                                #     index = 0
    loop_start:                                   #     loop {
        beq $t1 $a2, loop_end                     #         if index == len { break; }
        mulo $t2, $t1 4                           #         v         index * 4
        add $t3, $t2 $a0                          #         v         ^^^^^^^^^ + bArray
        lw $t3 ($t3)                              #         v  bArray[^^^^^^^^^^^^^^^^^^]
        mulo $t4, $t1 4                           #         v                                       index * 4
        add $t5, $t4 $a1                          #         v                                       ^^^^^^^^^ + cArray
        lw $t5 ($t5)                              #         v                                cArray[^^^^^^^^^^^^^^^^^^]
        bne $t3 $t5, if_end_4                     #         if ^^^^^^^^^^^^^^^^^^^^^^^^^^ == ^^^^^^^^^^^^^^^^^^^^^^^^^^ {
            add $t0, $t0 1                        #             count = count + 1
        if_end_4:                                 #         }
        add $t1, $t1 1                            #         index = index + 1
    j loop_start                                  #     }
    loop_end:                                     #     ^
    move $v0 $t0                                  #     return$v0 = count
                                                  #
    # reload used s registers from stack
    lw $ra, 0($sp)                                #     $ra = $sp[0]
    addiu $sp, $sp, 4                             #     $sp = $sp[1]
jr $ra                                            # }
main:                                             # main:
move $s0 $zero                                    # index = 0
loop_start_2:                                     # loop {
    lw $t0, len                                   #     v           @len
    beq $s0 $t0, loop_end_2                       #     if index == ^^^^ { break; }
    la $t0, x                                     #     v                  @x
    mulo $s1, $s0 4                               #     v      index * 4
    add $t0, $s1 $t0                              #     v      ^^^^^^^^^ + ^^
    lw $s2 ($t0)                                  #     a = @x[^^^^^^^^^^^^^^]
    la $t0, y                                     #     v                  @y
    mulo $s3, $s0 4                               #     v      index * 4
    add $t0, $s3 $t0                              #     v      ^^^^^^^^^ + ^^
    lw $s4 ($t0)                                  #     b = @y[^^^^^^^^^^^^^^]
    move $a0 $s2                                  #     v            a
    move $a1 $s4                                  #     v               b
    jal call_gcd                                  #     v        gcd(^, ^)
    move $s5, $v0                                 #     result = ^^^^^^^^^
    la $t0, z                                     #     v                       @z
    mulo $s6, $s0 4                               #     v           index * 4
    add $t0, $s6 $t0                              #     v           ^^^^^^^^^ + ^^
    sw $s5 ($t0)                                  #     result = @z[^^^^^^^^^^^^^^]
    print_str("GCD of (")                         #     print_str("GCD of (")
    li $v0 1                                      #     $v0 = 1
    move $a0 $s2                                  #     $a0 = value
    syscall                                       #     syscall
    print_str(", ")                               #     print_str(", ")
    li $v0 1                                      #     $v0 = 1
    move $a0 $s4                                  #     $a0 = value
    syscall                                       #     syscall
    print_str(") = ")                             #     print_str(") = ")
    li $v0 1                                      #     $v0 = 1
    move $a0 $s5                                  #     $a0 = value
    syscall                                       #     syscall
    print_str("\n")                               #     print_str("\n")
    add $s0, $s0 1                                #     index = index + 1
j loop_start_2                                    # }
loop_end_2:                                       # ^
print_str("Equal count: ")                        # print_str("Equal count: ")
la $a0, y                                         # v                    @y
la $a1, z                                         # v                        @z
lw $a2, len                                       # v                            @len
jal call_equal_count                              # v        equal_count(^^, ^^, ^^^^)
move $t0, $v0                                     # !TODO! = ^^^^^^^^^^^^^^^^^^^^^^^^^
li $v0 1                                          # $v0 = 1
move $a0 $t0                                      # $a0 = value
syscall                                           # syscall
print_str("\n")                                   # print_str("\n")
# Output:
#
# GCD of (20, 5) = 5
# GCD of (9, 7) = 1
# GCD of (432, 226) = 2
# GCD of (24, 18) = 6
# GCD of (49, 7) = 7
# GCD of (339, 9) = 3
# GCD of (63, 9) = 9
# Equal count: 3
# 
# -- program is finished running (dropped off bottom) --