import{t as e,C as t,r as n,c as r,d as a,a as s,b as l,i,F as o,S as p,M as u,e as c,f as d,E as m,g as f,k as g,h as v,j as y,o as x}from"./vendor.70bc6bbd.js";const h={"readmexample.masc":"\\\\.text\n\\\\j main\n\nfn gcd(a: i32, b: i32) i32 {\n    if b == 0 {return a;}\n    return gcd(b, a%b);\n}\n\n\\\\main:\n\nprint_int(gcd(25, 15));\n\n// ----- //\n\ninline fn print_int(value: i32) void {\n\t$v0 = 1;\n\t$a0 = value;\n\tsyscall();\n}\ninline fn syscall() void {\n\t\\\\syscall\n\t!clear $call;\n}","longestsequence.masc":"\\.data\n\\    array: .word -5, 10, 20, 14, 17, 26, 42, 22, 19, -5\n\\    length: 10\n\\.text\n\\j main\n\\\nfn longest_increasing_sequence(array: [*]i32, length: i32) i32 {\n    var current: i32 = 1;\n    var longest: i32 = 0;\n    var final: [*]i32 = &array[length];\n    if length <= 1 {return length;}\n    loop {\n        if &array[1] == final {return longest;}\n        var item: i32 = array[1];\n        var previous: i32 = array[0];\n        if item > previous {current = current + 1;}\n        if item <= previous {current = 1;}\n        if current > longest {longest = current;}\n        array = &array[1];\n    }\n}\n\\\n\\main:\nvar array: [*]i32 = @[*]i32:array;\nvar len: i32 = @i32:length;\nprint_int(longest_increasing_sequence(array, len));\n\n// ----- //\n\ninline fn print_int(value: i32) void {\n\t$v0 = 1;\n\t$a0 = value;\n\tsyscall();\n}\ninline fn syscall() void {\n\t\\syscall\n\t!clear $call;\n}","xorencrypt.masc":'\\.macro print_str (%str)\n\\    .data\n\\        string: .asciiz %str\n\\    .text\n\\        li $v0, 4\n\\        la $a0, string\n\\        syscall\n\\.end_macro\n\\.text\n\\j main\n\ninline fn syscall() void {\n\t\\syscall\n\t!clear $call;\n}\n\ninline fn read_string(buffer: [*]u8, max_len: u32) void {\n\t$v0 = 8;\n\t$a0 = buffer;\n\t$a1 = max_len;\n\tsyscall();\n}\n\ninline fn print_string(string: [*]u8) void {\n    $v0 = 4;\n    $a0 = string;\n    syscall();\n}\n\nfn read_until_newline(buffer: [*]u8, max_len: u32) void {\n\tread_string(buffer, max_len);\n\tvar addr: [*]u8 = buffer;\n\tloop {\n\t\tif addr[0] == 13 {break;}\n\t\tif addr[0] == 10 {break;}\n\t\taddr = &addr[1];\n\t}\n\tsave addr[0] = 0;\n}\n\nfn translate(message: [*]u8, key: [*]u8) void {\n\t\\# get length of key\n\tvar key_len: u32 = 0;\n\tloop {\n\t\tif key[key_len] == 0 {break;}\n\t\tkey_len = key_len + 1;\n\t}\n\t\n\t\\# encrypt/decrypt message\n\tvar index: u32 = 0;\n\tloop {\n\t\tif message[index] == 0 {break;}\n\t\tsave message[index] = message[index] ^ key[index % key_len];\n\t\tindex = index + 1;\n\t}\n}\n\n\\main:\n\n$sp = $sp - 256;\nvar key: [*]u8 = $sp + 128;\n\\\n\\print_str("Plain text:\\n  ")\nread_until_newline($sp, 128);\n\\\n\\print_str("Key:\\n  ")\nread_until_newline(key, 128);\n\\\n\\print_str("Encrypted:\\n  ")\ntranslate($sp, key);\nprint_string($sp);\n\\\n\\print_str("\\nDecrypted:\\n  ")\ntranslate($sp, key);\nprint_string($sp);\n\\print_str("\\n")',"fnreturn.masc":'\\.macro write_str (%str)\n\\    .data\n\\        string: .asciiz %str\n\\    .text\n\\        li $v0, 4\n\\        la $a0, string\n\\        syscall\n\\.end_macro\n\\.text\n\\j main\n\\\ninline fn syscall() void {\n\t\\syscall\n\t!clear $call;\n}\n\ninline fn write_int(value: i32) void {\n\t$v0 = 1;\n\t$a0 = value;\n\tsyscall();\n}\n\ninline fn inline_returns(innum: u32) i32 {\n    if innum == 1 {return 12;}\n    return 25;\n}\n\nfn returns(innum: u32) i32 {\n    if innum == 1 {return 15;}\n    return 34;\n}\n\nfn noreturn() void {}\n\\\n\\main:\nvar result1: i32 = inline_returns(0);\n\\write_str("expected 25: ")\nwrite_int(result1);\n\\write_str("\\n")\n\\\nvar result2: i32 = returns(1);\n\\write_str("expected 15: ")\nwrite_int(result2);\n\\write_str("\\n")\n\\\nnoreturn(); // make sure no unused move is generated\n\\\nvar result3: i32 = returns(0);\n\\write_str("expected 34: ")\nwrite_int(result3);\n\\write_str("\\n")\n\\\nvar result4: i32 = inline_returns(1);\n\\write_str("expected 12: ")\nwrite_int(result4);\n\\write_str("\\n")',"stack.masc":"\\.text\n$sp = $sp - 8;\nvar stack_value: [*]u32 = $sp;\nsave stack_value[0] = 5;\nsave stack_value[1] = 10;\nvar value: u32 = stack_value[1]; // expct 1($t0)\nvar pointer: [*]u32 = &stack_value[1]; // la 1($t0)\n\\\nvar index: u32 = 5;\nvar unused: u32 = stack_value[index];\n\\\nvar stack_u8: [*]u8 = $sp;\nvar unused2: u8 = stack_u8[index];","gcd.masc":'\\.macro print_str (%str)\n\\    .data\n\\        string: .asciiz %str\n\\    .text\n\\        li $v0, 4\n\\        la $a0, string\n\\        syscall\n\\.end_macro\n\\.text\n\\j main\n\ninline fn syscall() void {\n\t\\syscall\n\t!clear $call;\n}\n\ninline fn read_string(buffer: [*]u8, max_len: u32) void {\n\t$v0 = 8;\n\t$a0 = buffer;\n\t$a1 = max_len;\n\tsyscall();\n}\n\ninline fn print_string(string: [*]u8) void {\n    $v0 = 4;\n    $a0 = string;\n    syscall();\n}\n\ninline fn read_int() i32 {\n\t$v0 = 5;\n\tsyscall();\n\treturn $v0;\n}\n\ninline fn print_int(value: i32) void {\n\t$v0 = 1;\n\t$a0 = value;\n\tsyscall();\n}\n\nfn GCD(x: i32, y: i32) i32 {\n    if x < 0 {x = 0-x;}\n    if y < 0 {y = 0-y;}\n\tif x < y {\n\t\tvar temp: i32 = y;\n\t\ty = x;\n\t\tx = temp;\n\t}\n    loop {\n        var n: i32 = x % y;\n        x = y;\n        y = n;\n        if y <= 0 {break;}\n    }\n    return x;\n}\n\n\\main:\n\n\\print_str("Number 1:\\n  ")\n!clear $call;\nvar value1: i32 = read_int();\n\\print_str("Number 2:\\n  ")\n!clear $call;\nvar value2: i32 = read_int();\nvar gcd: i32 = GCD(value1, value2);\n\\\n\\print_str("GCD:\\n  ")\n!clear $call;\nprint_int(gcd);\n\\\n\\print_str("\\nLoop Test:\\n\\n")\n!clear $call;\n\n\\print_str("   .  -5 -4 -3 -2 -1  1  2  3  4  5\\n")\n\\print_str("  -|-------------------------------\\n")\n!clear $call;\nvar x: i32 = -5;\nloop {\n\tif x > 0 {\n\t\t\\print_str(" ")\n\t}\n\tprint_int(x);\n\t\\print_str(" | ")\n\t!clear $call;\n\tvar y: i32 = -5;\n\tloop {\n\t\t\\print_str("  ")\n\t\tvar gcd: i32 = GCD(x, y);\n\t\tprint_int(gcd);\n\t\ty = y + 1;\n\t\tif y == 0 {y = y + 1;}\n\t\tif y > 5 {break;}\n\t}\n\t\\print_str("\\n")\n\t!clear $call;\n\tx = x + 1;\n\tif x == 0 {x = x + 1;}\n\tif x > 5 {break;}\n}',"gcd_recursive.masc":'\\.macro print_str (%str)\n\\    .data\n\\        string: .asciiz %str\n\\    .text\n\\        li $v0, 4\n\\        la $a0, string\n\\        syscall\n\\.end_macro\n\\.data\n\\    x:   .word 20, 9, 432, 24, 49, 339, 63\n\\    y:   .word 5,  7, 226, 18, 7,  9,   9\n\\    z:   .word 0,  0, 0,   0,  0,  0,   0\n\\    len: .word 7\n\\.text\n\\j main\n\\\ninline fn print_int(value: i32) void {\n\t$v0 = 1;\n\t$a0 = value;\n\tsyscall();\n}\ninline fn syscall() void {\n\t\\syscall\n\t!clear $call;\n}\n\\\nfn gcd(a: i32, b: i32) i32 {\n    if b == 0 {return a;}\n    return gcd(b, a%b);\n}\n\\\nfn equal_count(bArray: [*]i32, cArray: [*]i32, len: i32) i32 {\n    var count: i32 = 0;\n    var index: i32 = 0;\n\tvar size = len * 4;\n    loop {\n        if index == size {break;}\n        if bArray[+index] == cArray[+index] {count = count + 1;}\n\t\tindex = index + 4;\n    }\n    return count;\n}\n\\\n\\main:\nvar index: i32 = 0;\nvar size = @i32:len * 4;\nloop {\n    if index == size {break;}\n    \\\n    var a = @[*]i32:x[+index];\n    var b = @[*]i32:y[+index];\n    var result = gcd(a, b);\n    save @[*]i32:z[+index] = result;\n    \\\n    \\print_str("GCD of (")\n    !clear $call;\n    \\\n    print_int(a);\n    \\\n    \\print_str(", ")\n    !clear $call;\n    \\\n    print_int(b);\n    \\\n    \\print_str(") = ")\n    !clear $call;\n    \\\n    print_int(result);\n    \\\n    \\print_str("\\n")\n    !clear $call;\n\t\\\n\tindex = index + 4;\n}\n\\\n\\print_str("Equal count: ")\n!clear $call;\n\\\nprint_int(equal_count(@[*]i32:y, @[*]i32:z, @i32:len));\n\\\n\\print_str("\\n")\n!clear $call;\n\\\n\\\n\\\n\\\n\\\n\\# Output:\n\\#\n\\# GCD of (20, 5) = 5\n\\# GCD of (9, 7) = 1\n\\# GCD of (432, 226) = 2\n\\# GCD of (24, 18) = 6\n\\# GCD of (49, 7) = 7\n\\# GCD of (339, 9) = 3\n\\# GCD of (63, 9) = 9\n\\# Equal count: 3\n\\# \n\\# -- program is finished running (dropped off bottom) --'};function _(e){return"string"==typeof e?j(e):Array.isArray(e)?E(...e):e instanceof RegExp?S(e):e}let b,$=0;function w(e,t){let n,r={parse:(t,r)=>{r.index>b.index&&(b=r),$++;let a=e(t,r);if($--,$>5e3)throw new Error("bad");return!a.error&&n?{...a,val:n(a.val,a.pos)}:a},toString:()=>t(),scb:e=>(n=e,r)};return r}function k(...e){let t=e.map((e=>_(e)));return w(((e,n)=>{let r=0,a=[];for(let s of t){let t=s.parse(e,n);if(!t.error)return{type:"or",error:!1,val:{data:t,choiceIndex:r},pos:t.pos};a.push(t.message),r++}return{error:!0,message:"or failed. "+a.map((e=>"("+e+")")).join(", ")}}),(()=>"( "+t.map((e=>e.toString())).join(" | ")+" )"))}function E(...e){let t=e.map((e=>_(e)));return w(((e,n)=>{let r=n,a=[];for(let s of t){let t=s.parse(e,r);if(t.error)return t;r=t.pos.end,a.push(t)}return{type:"p",error:!1,val:a,pos:{start:n,end:r}}}),(()=>"( "+t.map((e=>e.toString())).join(" ")+" )"))}function j(e){return w(((t,n)=>{let r={...n};for(let a=0;a<e.length;a++){let s=t.str[n.index+a];if(s!==e[a])return{error:!0,message:"str failed"};r.col++,r.index++,"\n"==s&&(r.line++,r.col=0)}return{type:"c",error:!1,val:e,pos:{start:n,end:r}}}),(()=>JSON.stringify(e)))}function A(e,t){let n={...e};for(let r=0;r<t.length;r++){let e=t[r];n.col++,n.index++,"\n"==e&&(n.line++,n.col=0)}return n}function S(e){return w(((t,n)=>{let r=t.str.substr(n.index),a=e.exec(r);if(!a)return{error:!0,message:"match failed"};if(!r.startsWith(a[0]))throw new Error("Regex must start with ^");return{type:"regex",error:!1,val:a,pos:{start:n,end:A(n,a[0])}}}),(()=>e.toString()))}function C(e){let t=_(e);return w(((e,n)=>{let r=n,a=[];for(;;){let n=t.parse(e,r);if(n.error)break;if(n.pos.start.index===n.pos.end.index)break;a.push(n),r=n.pos.end}return{type:"star",error:!1,val:a,pos:{start:n,end:r}}}),(()=>"*"+t.toString()))}function L(e){let t=_(e);return w(((e,n)=>{let r=n,a=t.parse(e,r);return a.error?{type:"star",error:!1,val:void 0,pos:{start:n,end:n}}:{type:"star",error:!1,val:{item:a.val},pos:{start:n,end:a.pos.end}}}),(()=>"?"+t.toString()))}let R=function(){let e={},t=[];return{get:t=>e[t]?e[t]:function(e,t){return{parse:(n,r)=>{if(!e)throw new Error("Missing "+t);return e().parse(n,r)},toString:()=>e()?e().toString():"[31m["+t+"](B[m",scb:()=>{throw new Error("Cannot set cb of temporary")}}}((()=>e[t]),t),set(n,r){let a=_(r);e[n]=function(e,t){let n=_(t);return{parse:(t,r)=>{let a=n.parse(t,r);return a.error&&(a.message+=" (from "+e+")"),a},toString:()=>e,scb:n.scb}}(n,a),t.push({name:n,parse:a})},print:()=>t.map((({name:e,parse:t})=>e+" = "+t.toString()+";")).join("\n")}}(),z=new Proxy({},{get:(e,t,n)=>"string"==typeof t?R.get(t):Reflect.get(e,t,n)});R.set("_",C(k(/^\s+/,/^\/\/.*/,/^\/\*[\s\S]+?\*\//)).scb((()=>null)));let D=z._,N=function(e){let t=_(e);return w(((e,n)=>{let r=n,a=t.parse(e,r);return a.error?a:a.pos.start.index===a.pos.end.index?{error:!0,message:"required not found"}:{type:"star",error:!1,val:{item:a.val},pos:{start:n,end:a.pos.end}}}),(()=>"!"+t.toString()))}(D);function I(e,t,n,r){return E(t,C(E(D,k(...e).scb((e=>e.data.val)),D,t).scb((e=>({op:e[1].val,val:e[3].val})))).scb((e=>e.map((e=>e.val))))).scb(((e,t)=>{let[n,r]=[e[0].val,e[1].val];if(0===r.length)return n;if(1!==r.length)throw new Error("multi-part binaryexpr niy");let a=r[0];return((e,t,n,r)=>({expr:"op",op:e,left:t,right:n,pos:r}))(a.op,n,a.val,t)}))}R.set("identifier",S(/^[a-zA-Z_\x7f-\uffff][a-zA-Z0-9_\x7f-\uffff]*/).scb((e=>e[0]))),R.set("code",C(E(D,k(z.ilasmlyn,z.clrlyn,z.iflyn,z.looplyn,z.breaklyn,z.continuelyn,z.fnlyn,z.calllyn,z.setvarlyn,z.defvarlyn,z.storelyn,z.returnlyn).scb((e=>e.data.val)),D).scb((e=>e[1].val))).scb((e=>e.map((e=>e.val))))),R.set("ilasmlyn",S(/^\\{1,2}([^\r\n]*)(?:\r?\n|$)/).scb(((e,t)=>((e,t)=>({ast:"ilasm",ilasm:e,pos:t}))(e[1],t)))),R.set("clrlyn",E("!clear",N,"$",z.identifier,D,";").scb(((e,t)=>((e,t)=>({ast:"clear",registers:e,pos:t}))([e[3].val],t)))),R.set("iflyn",E("if",D,z.expr,D,k("==","!=","<=","<",">",">=").scb((e=>e.data.val)),D,z.expr,D,"{",z.code,"}").scb(((e,t)=>({ast:"if",condleft:e[2].val,condition:e[4].val,condright:e[6].val,code:e[9].val,pos:t})))),R.set("fnlynarg",E(z.identifier,D,":",D,z.type).scb(((e,t)=>({arg:"arg",name:e[0].val,type:e[4].val,pos:t})))),R.set("fnlyn",E(L("inline"),D,"fn",D,z.identifier,D,"(",D,C(E(z.fnlynarg,D,",",D).scb((e=>e[0].val))).scb((e=>e.map((e=>e.val)))),L(z.fnlynarg),D,")",D,z.type,D,"{",z.code,"}").scb(((e,t)=>({ast:"fn",name:e[4].val,inline:!!e[0].val,args:e[9].val?[...e[8].val,e[9].val.item]:e[8].val,body:e[16].val,type:e[13].val,pos:t})))),R.set("looplyn",E("loop",D,"{",z.code,"}").scb(((e,t)=>({ast:"loop",code:e[3].val,pos:t})))),R.set("breaklyn",E("break",D,";").scb(((e,t)=>({ast:"break",pos:t})))),R.set("continuelyn",E("continue",D,";").scb(((e,t)=>({ast:"continue",pos:t})))),R.set("returnlyn",E("return",N,z.expr,D,";").scb(((e,t)=>({ast:"return",returnv:e[2].val,pos:t})))),R.set("setvarlyn",E(z.vorexpr,D,"=",D,z.expr,D,";").scb(((e,t)=>((e,t,n)=>({ast:"setvar",name:e,value:t,pos:n}))(e[0].val,e[4].val,t)))),R.set("defvarlyn",E("var",N,z.identifier,D,L(E(":",D,z.type,D).scb((e=>e[2].val))),"=",D,z.expr,D,";").scb(((e,t)=>((e,t,n,r)=>({ast:"defvar",name:e,type:t,default:n,pos:r}))(e[2].val,e[4].val?e[4].val.item:void 0,e[7].val,t)))),R.set("storelyn",E("save",N,z.expr,D,"=",D,z.expr,D,";").scb(((e,t)=>({ast:"save",saveloc:e[2].val,value:e[6].val,pos:t})))),R.set("vorexpr",k(z.varexpr,z.regexpr).scb((e=>e.data.val))),R.set("varexpr",E(z.identifier).scb(((e,t)=>((e,t)=>({expr:"variable",var:e,pos:t}))(e[0].val,t)))),R.set("regexpr",E("$",z.identifier).scb(((e,t)=>((e,t)=>({expr:"register",register:e,pos:t}))(e[1].val,t)))),R.set("dataexpr",E("@",D,z.type,D,":",D,z.identifier).scb(((e,t)=>({expr:"data",pos:t,name:e[6].val,type:e[2].val})))),R.set("type",k(k("u32","i32","u8","any","void").scb(((e,t)=>((e,t)=>({type:"builtin",kind:e,pos:t}))(e.data.val,t))),E("[*]",D,z.type).scb(((e,t)=>({type:"arrayptr",child:e[2].val,pos:t}))),E("*",D,z.type).scb(((e,t)=>({type:"pointer",child:e[2].val,pos:t})))).scb((e=>e.data.val))),R.set("expr",E(z.addsubexpr).scb((e=>e[0].val))),R.set("addsubexpr",I(["+","-"],z.muldivexpr)),R.set("muldivexpr",I(["*","/"],z.modexpr)),R.set("modexpr",I(["%"],z.bitwiseexpr)),R.set("bitwiseexpr",I(["^"],z.prefixexpr)),R.set("callexpr",E(z.identifier,D,"(",D,C(E(z.expr,D,",",D).scb((e=>e[0].val))).scb((e=>e.map((e=>e.val)))),L(z.expr),D,")").scb(((e,t)=>({expr:"call",name:e[0].val,args:e[5].val?[...e[4].val,e[5].val.item]:e[4].val,pos:t})))),R.set("calllyn",E(z.callexpr,D,";").scb(((e,t)=>({ast:"expr",expr:e[0].val,pos:t})))),R.set("inmsuffix",E("[+",D,z.expr,D,"]",D).scb(((e,t)=>n=>({expr:"arrayindexnomul",from:n,index:e[2].val,pos:t})))),R.set("indexsuffix",E("[",D,z.expr,D,"]",D).scb(((e,t)=>n=>({expr:"arrayindex",from:n,index:e[2].val,pos:t})))),R.set("ptrfollowsuffix",E(".*",D).scb(((e,t)=>e=>({expr:"pointer",from:e,pos:t})))),R.set("addressofexpr",E("&",D,z.prefixexpr).scb(((e,t)=>({expr:"addressof",of:e[2].val,pos:t})))),R.set("prefixexpr",k(z.addressofexpr,z.suffixexpr).scb((e=>e.data.val))),R.set("suffixexpr",E(z.noopexpr,D,C(k(z.inmsuffix,z.indexsuffix,z.ptrfollowsuffix))).scb((e=>{let t=e[0].val;for(let n of e[2].val){t=(0,n.val.data.val)(t)}return t}))),R.set("noopexpr",k(z.callexpr,z.vorexpr,z.undefinedexpr,z.immediateexpr,z.dataexpr).scb((e=>e.data.val))),R.set("undefinedexpr",j("undefined").scb(((e,t)=>({expr:"undefined",pos:t})))),R.set("immediateexpr",S(/^-?\d+/).scb(((e,t)=>({expr:"immediate",value:e[0],pos:t}))));const G=R.print();console.log(G);let W=()=>"!TODO"+(new Error).stack.split("\n")[2].replace(/^.+:(\d+?):(\d+?)$/,":$1:$2")+"!",M=(e,t)=>{let n=new Error(e.start.line+1+":"+(e.start.col+1)+"-"+(e.end.line+1)+":"+(e.end.col+1)+" - "+t);return n.pos=e,n};function q(e,t){const n=function(e,t){b={index:-1,line:0,col:0};let n=z.code.parse({str:e},{index:0,col:0,line:0});console.log();let r=n.val||n;if(b.index!==e.length){console.log(b);const n="undefined"!=typeof process?process.stdout.columns:80;let r=" ".repeat(10),a=b.line+1,s=b.col+1,l="      "+" ".repeat(a.toString().length),i=n-l.length-1,o=i-10,p=(r+e+" ".repeat(n)).substr(b.index,i).split("\n").join("âŽ"),u={error:"[31m",green:"[32m",number:"[36m",clear:"(B[m",linedisp:"[97m[40m",linenodisp:"[30m[47m"};throw console.log(u.green+t+u.clear+":"+u.number+a+u.clear+":"+u.number+s+u.clear+": "+u.error+"Error"+u.clear),console.log(u.linenodisp+" "+a+"  "+u.linedisp+"  ",p+u.clear+"â€¦"),console.log(l+u.error+"          "+"~".repeat(o)+u.clear),new Error(a+":"+s+" - Parse Error.")}return console.log(),r}(e.split("\t").join("    "),t);let r=de(n),a=function(e){let t=[],n=new Map,r=(e,a)=>{if("string"==typeof e)return{text:e,idxs:[]};if(Array.isArray(e)){let t=[];return{text:e.map((e=>{let n=r(e,a);return a+=n.text.length,t.push(...n.idxs),n.text})).join(""),idxs:t}}let s=n.get(e);if(s){let r=0;for(let e of s)t[e].value=" ".repeat(a)+t[e].value,t[e].used=!0,r=t[e].value.trim().length;return n.delete(e),{text:"^".repeat(r),idxs:[...s]}}let l=r(e.msg,a);if(0!==l.idxs.length)throw new Error("uh oh ");return{text:l.text,idxs:[]}};e.forEach(((e,a)=>{let s=e.comment,l="    ".repeat(e.indent||0),i=s.out?s.out+" = ":"",o=r(s.msg,0),p=t.length;if(t.push({indent:l,value:o.text,assignto:i,used:!1,idxs:new Error("uh oh")}),p!==a)throw new Error("never");let u=[...o.idxs,p];n.set(s,u),t[p].idxs=u}));for(let i of t){if(i.used)continue;let e=" ".repeat(i.assignto.length);for(let n of i.idxs)if(t[n]!==i){if(!t[n].used)throw new Error("uh oh");t[n].value=e+t[n].value}i.value=i.assignto+i.value}let a=!1,s=t.map((e=>e.used?e.indent+e.value.replace(" ",a?"|":(a=!0,".")):(a=!1,e.indent+e.value))),l=[];return e.forEach(((e,t)=>{let n="    ".repeat(e.indent||0)+e.text;e.text.trim().startsWith("#")?l.push(n):l.push(n.padEnd(50," ")+("# "+s[t]).trim())})),l}(function(e){let t=e,n=!1;t=t.filter(((e,r)=>{var a;let s=e.text.trim();if(s.startsWith("#"))return!0;if(s.match(/%%:label:.+?:%%:/)&&(n=!1),n)return!1;let l=(null==(a=t.find(((e,t)=>t>r&&X(e))))?void 0:a.text)||"";if(s.startsWith("j ")){let e=s.match(/%%:ref:label:(.+?):%%/);if(e&&l.includes("%%:label:"+e[1]+":%%:"))return!1}return(s.startsWith("jr ")||s.startsWith("j "))&&(n=!0),!0}));let r=new Set;for(let s of t){let e=s.text.matchAll(/%%:ref:label:(.+?):%%/g);for(let t of e)r.add(t[1])}let a=[...r];return t.filter((e=>{let t=e.text.match(/%%:label:(.+?):%%:/);return!t||a.includes(t[1])})).map((e=>({text:e.text.replace(/%%:(?:ref:)?label:(.+?):%%/g,"$1"),comment:e.comment,indent:e.indent})))}(fe(me(r)))).join("\n");return P={},T=0,{final:a,intermediate:r,ast:n}}let O=e=>{throw console.log(e),new Error("unexpected enumthing")},T=0;function F(){return"%%:variable:"+T+++":%%"}function K(e){return"%%:register:"+e+":%%"}let P={};function B(e){let t;return P[e]?(t=e+"_"+ ++P[e],P[t]&&(t=B(t).raw)):t=e,P[e]=(P[e]||0)+1,{def:"%%:label:"+t+":%%",ref:"%%:ref:label:"+t+":%%",raw:t}}let Y={call:["v0","v1","a0","a1","a2","a3","t0","t1","t2","t3","t4","t5","t6","t7","ra"]},V=["t0","t1","t2","t3","t4","t5","t6","t7","s0","s1","s2","s3","s4","s5","s6","s7"],J=/%%:(?:out\:)?register:(.+?):%%/g;function U(e){return{text:e.text,comment:e.comment,indent:(e.indent||0)+1}}function X(e){let t=e.text.trim();return!!t&&(!t.startsWith("%:%:")&&(!t.startsWith("{{")&&!t.startsWith("%:%:")))}function Z(e){return e.filter((e=>X(e)))}function H(e){return"builtin"===e.type?{type:e.kind}:"pointer"===e.type?{type:"pointer",child:H(e.child)}:"arrayptr"===e.type?{type:"arrayptr",child:H(e.child)}:O(e)}function Q(e,t){if("immediate"===t.expr)return{value:+t.value}}function ee(e,t,n){let r=Q(0,t);return r?{reg:""+r.value,typ:{type:"any"},cmnt:""+r.value}:te(e,t,n)}function te(e,t,n){var r=Q(0,t);if(r&&0===r.value)return{reg:K("zero"),typ:{type:"any"},cmnt:"0"};if("register"===t.expr){let e="sp"===t.register?{type:"arrayptr",child:{type:"any"}}:{type:"any"};return{reg:K(t.register),typ:e,cmnt:"$"+t.register}}if("variable"===t.expr){let n=e.get(t.var);if(!n)throw M(t.pos,"variable not found "+t.var+" (at: L"+t.pos.start.line+")");return{reg:n.tempname,typ:n.type,cmnt:t.var}}if("call"===t.expr&&n){let r=e.getfn(t.name);if(!r)throw M(t.pos,"unknown fn "+t.name);return r.call(t.args,e,n)}if(n){let r=F(),a=se(e,t,{reg:r,name:W()},n);return{typ:a.type,reg:r,cmnt:a.cmnt}}return"%%__EXPR__NOT__AVAILABLE%%"}function ne(e,t,n){if("any"!==e.type){if("any"===t.type)return e;if(t.type===e.type)return e;throw M(n,"Incompatible Types: "+e.type+", "+t.type)}return"any"!==t.type?t:{type:"any"}}function re(e){return e.replace("%%:","%%:out:")}function ae(e,t,n,r,a,s){const l=n;if("arrayindex"!==l.expr&&"pointer"!==l.expr&&"arrayindexnomul"!==l.expr)throw M(l.pos,"Expected dereferencingexpr eg .* or [i] or [+i], got "+l.expr);let i="data"===l.from.expr?{typ:H(l.from.type),dataaddr:l.from.name,cmnt:"@"+l.from.name}:te(s,l.from,a);if("pointer"===l.expr){if("pointer"!==i.typ.type)throw M(l.pos,"Can only dereference *pointer. got "+i.typ.type)}else if("arrayindex"===l.expr||"arrayindexnomul"===l.expr){if("arrayptr"!==i.typ.type)throw M(l.pos,"Can only index [*]pointer. got "+i.typ.type)}else O(l);if("pointer"!==i.typ.type&&"arrayptr"!==i.typ.type)throw new Error("never");let o=function(e){if("any"===e.type)throw new Error("Cannot sizeof any");return"u32"===e.type||"i32"===e.type?4:"u8"===e.type?1:"void"===e.type?0:"pointer"===e.type||"arrayptr"===e.type?4:O(e)}(i.typ.child),p=o;"arrayindexnomul"===l.expr&&(p=1);let u=4===o?"w":1===o?"b":(()=>{throw M(l.pos,"unsupported size "+p+"; expected 1 or 4 byte size.")})(),c="addressof"===r?"la":"load"===r?"l"+u+(1===o?"u":""):"store"===r?"s"+u:O(r),d="store"===r?e.reg:re(e.reg),m="store"===r?[" = ",e.name]:"",f={out:"string"==typeof e.name?e.name:"~_~+_~_+~REMOVE THIS*%#&*@)$)",msg:{msg:"You should never see this !!!+!+!+!+!+!)_++#!+_#*(!+*!#(+)#!(*!#*()!#*#!*)!#*+)_!#()_!#+_()#!_()+"}};if("pointer"===l.expr)f.msg=["&",i.cmnt,m],"dataaddr"in i?a.push({text:`${c} ${d} ${i.dataaddr}`,comment:f}):a.push({text:`${c} ${d} (${i.reg})`,comment:f});else{let e=Q(0,l.index);if(e){let t=e.value*p;f.msg=[i.cmnt,"["+e.value+"]",m],"dataaddr"in i?a.push({text:`${c} ${d} ${i.dataaddr}+${t||""}`,comment:f}):a.push({text:`${c} ${d} ${t||""}(${i.reg})`,comment:f})}else{let e,t=te(s,l.index,a);if("u32"!==t.typ.type&&"i32"!==t.typ.type)throw M(l.pos,"Index must be u32 or i32");if(1!=p){let n={out:W(),msg:[t.cmnt," * "+p]};e={cmnt:n,reg:F()},a.push({text:`mulo ${e.reg}, ${t.reg} ${p}`,comment:n})}else e={cmnt:t.cmnt,reg:t.reg};if("dataaddr"in i)f.msg=["(",e.cmnt," + ",i.cmnt,").*",m],a.push({text:`${c} ${d} ${i.dataaddr}(${e.reg})`,comment:f});else{let t=F(),n={out:W(),msg:[e.cmnt," + ",i.cmnt]};a.push({text:`addu ${re(t)}, ${e.reg} ${i.reg}`,comment:n}),f.msg=["(",n,").*",m],a.push({text:`${c} ${d} (${t})`,comment:f})}}}return{type:"addressof"===r?i.typ:"load"===r||"store"===r?i.typ.child:O(r),cmnt:f}}function se(e,t,n,r){let a=re(n.reg),s=n.name,l=te(e,t);if("%%__EXPR__NOT__AVAILABLE%%"!==l){if(l.reg===a)return{type:l.typ,cmnt:l.cmnt};let e={out:s,msg:l.cmnt};return r.push({text:`move ${a} ${l.reg}`,comment:e}),{type:l.typ,cmnt:e}}if("immediate"===t.expr){let e={out:s,msg:""+t.value};return r.push({text:`li ${a} ${t.value}`,comment:e}),{type:{type:"any"},cmnt:e}}if("op"===t.expr){let n=te(e,t.left,r),l=ee(e,t.right,r),i=ne(n.typ,l.typ,t.pos);if("^"===t.op){let e;if("u8"!==i.type&&"u32"!==i.type)throw M(t.pos,"unsupported type "+i.type);return e={out:s,msg:[n.cmnt," ^ ",l.cmnt]},r.push({text:`xor ${a} ${n.reg} ${l.reg}`,comment:e}),{type:i,cmnt:e}}let o,p={"+":"add","-":"sub","*":"mulo","/":"div","%":"rem"}[t.op];if("u32"===i.type||"arrayptr"===i.type)o="u";else{if("i32"!==i.type)throw M(t.pos,"Add does not support type "+i.type);o=""}let u={out:s,msg:[n.cmnt," "+t.op+" ",l.cmnt]};return r.push({text:`${p}${o} ${a}, ${n.reg} ${l.reg}`,comment:u}),{type:i,cmnt:u}}if("addressof"===t.expr)return ae(n,0,t.of,"addressof",r,e);if("arrayindex"===t.expr||"pointer"===t.expr||"arrayindexnomul"===t.expr)return ae(n,0,t,"load",r,e);if("undefined"===t.expr)return{type:{type:"any"},cmnt:"undefined"};if("call"===t.expr){let n=e.getfn(t.name);if(!n)throw M(t.pos,"unknown fn "+t.name);let l=n.call(t.args,e,r),i={out:s,msg:l.cmnt};return r.push({text:"move "+a+", "+l.reg,comment:i}),{type:l.typ,cmnt:i}}if("data"===t.expr){let e=H(t.type),n={out:s,msg:"@"+t.name};return"pointer"===e.type||"arrayptr"===e.type?r.push({text:`la ${a}, ${t.name}`,comment:n}):r.push({text:`lw ${a}, ${t.name}`,comment:n}),{type:e,cmnt:n}}throw M(t.pos,"Not implemented expr: "+t.expr)}function le(e,t=!0){let n,r,a=t,s=new Map,l=new Map;return{getfn:t=>l.get(t)||(e?e.getfn(t):void 0),setfn(e,t){if(l.has(e))throw new Error("fn already defined: "+e);l.set(e,t)},get(t){let n=s.get(t);return!n&&e&&a?e.get(t):n},set(e,t){if(s.get(e))throw new Error("variable already defined: "+e);s.set(e,t)},getLoop:()=>n||(e&&a?e.getLoop():void 0),setLoop(e){if(n)throw new Error("override latest loop");n=e},getFnReturn:()=>r||(e&&a?e.getFnReturn():void 0),setFnReturn(e,t,n){if(r)throw new Error("override latest fn");r={outvar:e,outvarname:t,fnreturnf:n}}}}function ie(e,t){let n=H(e.type),r=e.args.map((e=>({typ:H(e.type),name:e.name})));t.setfn(e.name,{call:(a,s,l)=>{let i=B(e.name+"_return"),o=le(t),p=F();if(o.setFnReturn(p,"return",((e,t,r)=>{ne(n,e,{start:{line:-1,col:-1,index:-1},end:{line:-1,col:-1,index:-1}}),t.push({text:"j "+i.ref,comment:{msg:["return",r?[" ",r]:"",";"]}})})),a.length!==r.length)throw M(a[0].pos,"wrong arg count");let u=[];r.forEach(((e,t)=>{let n=a[t],r=F(),i=se(s,n,{reg:r,name:W()},l);ne(i.type,e.typ,n.pos),0!==t&&u.push(", "),u.push(i.cmnt),o.set(e.name,{type:e.typ,tempname:r})}));let c={msg:[e.name+"(",u,")"]},d=de(e.body,o);return l.push(...d.map(((e,t)=>({text:e.text,comment:0==t?c:{msg:[]},indent:e.indent})))),l.push({text:i.def+":",comment:{msg:"}"}}),{typ:n,reg:p,cmnt:[e.name+"(",u,")"]}}})}let oe=["a0","a1","a2","a3"];function pe(e){return"u32"===e.type||"i32"===e.type||"u8"===e.type||"void"===e.type?e.type:"arrayptr"===e.type?"[*]"+pe(e.child):"pointer"===e.type?"*"+pe(e.child):"any"===e.type?"word":O(e)}function ue(e,t){let n=H(e.type),r=e.args.map((e=>({typ:H(e.type),name:e.name}))),a=B("call_"+e.name),s=B("deinit_"+e.name);t.setfn(e.name,{call:(t,s,l)=>{if(t.length!==r.length)throw M(t[0].pos,"wrong arg count");let i=[];r.forEach(((e,n)=>{let a=t[n],o="var $"+oe[n]+" ("+r[n].name+")",p=se(s,a,{reg:K(oe[n]),name:o},l);0!=n&&i.push(", "),i.push(p.cmnt),ne(p.type,e.typ,a.pos)}));let o=K("v0"),p={out:o,msg:[e.name+"(",i,")"]};return l.push({text:"jal "+a.ref,comment:p}),l.push({text:"%%{{MARK_CLEAR:"+Y.call.join(",")+"}}%%",comment:{msg:"You should never see this !!!+!+!+!+!+!)_++#!+_#*(!+*!#(+)#!(*!#*()!#*#!*)!#*+)_!#()_!#+_()#!_()+"}}),{typ:n,reg:o,cmnt:p}},real:{startLabel:a,deinitLabel:s,body:e.body,name:e.name,args:r,returntype:n}})}function ce(e,t,n){let r=le(e,!1);r.setFnReturn(K("v0"),"return$v0",((e,t,r)=>{ne(e,n.returntype,{start:{line:-1,col:-1,index:-1},end:{line:-1,col:-1,index:-1}}),t.push({text:"j "+n.deinitLabel.ref,comment:{msg:["return",r?[" ",r]:"",";"]}})}));let a=[];n.args.forEach(((e,t)=>{let n=F();se(r,{expr:"register",register:oe[t],pos:"!!this should never happen!!"},{reg:n,name:e.name},a),r.set(e.name,{tempname:n,type:e.typ})}));let s=[];s.push(...a),s.push({text:"# body",comment:{msg:[]}}),s.push(...de(n.body,r));let l=me(s),i=new Set;for(let d of l)for(let e of d.text.matchAll(J))e[1].match(/^s[0-7]$/)&&i.add(e[1]);let o=[...i,"ra"];console.log(o);let p=[];o.length>0&&(p.push({text:"# save used s registers to stack",comment:{msg:[]}}),p.push({text:"subiu $sp, $sp, "+4*o.length,comment:{out:"$sp",msg:"&$sp[-"+o.length+"]"}})),o.forEach(((e,t)=>{p.push({text:"sw $"+e+", "+4*t+"($sp)",comment:{msg:"$sp["+t+"] = $"+e}})})),o.length>0&&p.push({text:"",comment:{msg:[]}}),p.push(...fe(l)),o.length>0&&p.push({text:"",comment:{msg:[]}}),o.length>0&&p.push({text:n.deinitLabel.def+":",comment:{msg:"cleanup:"},indent:-1}),o.length>0&&p.push({text:"# reload used s registers from stack",comment:{msg:[]}}),o.forEach(((e,t)=>{p.push({text:"lw $"+e+", "+4*t+"($sp)",comment:{out:"$"+e,msg:"$sp["+t+"]"}})})),o.length>0&&p.push({text:"addiu $sp, $sp, "+4*o.length,comment:{out:"$sp",msg:"&$sp["+o.length+"]"}});let u=B("skip_"+n.name),c=["# ====================","# jal "+n.startLabel.raw,"# args:"+(0===n.args.length?" none":""),...n.args.map(((e,t)=>"#    $"+oe[t]+": "+e.name+" - "+pe(e.typ))),...("# return:"+("void"===n.returntype.type?" none":"\n#    $v0: "+pe(n.returntype))).split("\n"),"# ===================="];t.push(...c.map((e=>({text:e,comment:{msg:[]}})))),t.push({text:n.startLabel.def+":",comment:{msg:"fn "+n.name+"("+n.args.map((e=>e.name+": "+pe(e.typ))).join(", ")+") "+pe(n.returntype)+"{"}}),t.push(...p.map((e=>U(e)))),t.push({text:"jr $ra",comment:{msg:"}"}}),t.push({text:u.def+":",comment:{msg:[]}})}function de(e,t){let n=[],r=le(t);for(const a of e)"fn"===a.ast&&(a.inline?ie(a,r):ue(a,r));for(let a of e){let e=[];if("ilasm"===a.ast)e.push({text:a.ilasm,comment:{msg:a.ilasm}});else if("clear"===a.ast)e.push({text:"%%{{MARK_CLEAR:"+a.registers.flatMap((e=>Y[e]||[e])).join(",")+"}}%%",comment:{msg:"You should never see this !!!+!+!+!+!+!)_++#!+_#*(!+*!#(+)#!(*!#*()!#*#!*)!#*+)_!#()_!#+_()#!_()+"}});else if("defvar"===a.ast){let t,n=F(),s=se(r,a.default,{reg:n,name:a.name},e),l=s.cmnt;if(a.type){t=ne(H(a.type),s.type,a.pos),l.out="var "+l.out+": "+pe(t)}else t=s.type,l.out="var "+l.out;r.set(a.name,{type:t,tempname:n})}else if("setvar"===a.ast){let t=te(r,a.name),n=se(r,a.value,{reg:t.reg,name:t.cmnt.toString()},e);ne(t.typ,n.type,a.pos)}else if("if"===a.ast){let t,n=te(r,a.condleft,e),s=ee(r,a.condright,e),l=ne(n.typ,s.typ,a.pos);if("u32"===l.type)t="u";else if("u8"===l.type)t="u";else if("i32"===l.type)t="";else if("arrayptr"===l.type)t="u";else{if("pointer"!==l.type)throw M(a.pos,"unsupported if type "+l);t="u"}let i,o=B("if_end"),p=o.ref,u=!0,c=de(a.code,r),d=Z(c);if(1===d.length&&d[0].text.trim().startsWith("j ")){p=d[0].text.trim().split(" ").slice(1).join(" "),i=d[0].comment,u=!1}let m={"==":"!=","!=":"==","<=":">","<":">=",">":"<=",">=":"<"},f={"!=":"bne","==":"beq","<":"blt","<=":"ble",">=":"bge",">":"bgt"},g=u?m[a.condition]:a.condition,v=f[g],y={msg:["if ",n.cmnt," "+a.condition+" ",s.cmnt,u?" {":[" { ",i," }"]]};"!="===g&&"0"===s.reg?e.push({text:`bnez ${n.reg}, ${p}`,comment:y}):"=="===g&&"0"===s.reg?e.push({text:`beqz ${n.reg}, ${p}`,comment:y}):e.push({text:`${v}${t} ${n.reg} ${s.reg}, ${p}`,comment:y}),u&&(e.push(...c.map((e=>U(e)))),e.push({text:o.def+":",comment:{msg:"}"}}))}else if("loop"===a.ast){let t=B("loop_start"),n=B("loop_end"),s=le(r);s.setLoop({start:t.ref,end:n.ref});let l=de(a.code,s);e.push({text:t.def+":",comment:{msg:"loop {"}}),e.push({text:"%%{{controlflow_mark::"+t.raw+"}}%%",comment:{msg:"You should never see this !!!+!+!+!+!+!)_++#!+_#*(!+*!#(+)#!(*!#*()!#*#!*)!#*+)_!#()_!#+_()#!_()+"}}),e.push(...l.map((e=>U(e)))),e.push({text:"%%{{controlflow_goto::"+t.raw+"}}%%",comment:{msg:"You should never see this !!!+!+!+!+!+!)_++#!+_#*(!+*!#(+)#!(*!#*()!#*#!*)!#*+)_!#()_!#+_()#!_()+"}}),e.push({text:"j "+t.ref,comment:{msg:"}"}}),e.push({text:n.def+":",comment:{msg:"^"}})}else if("continue"===a.ast){let t=r.getLoop();if(!t)throw M(a.pos,"continue not in loop");e.push({text:"j "+t.start,comment:{msg:"continue;"}})}else if("break"===a.ast){let t=r.getLoop();if(!t)throw M(a.pos,"break not in loop");e.push({text:"j "+t.end,comment:{msg:"break;"}})}else if("return"===a.ast){let t=r.getFnReturn();if(!t)throw M(a.pos,"return not in fn");let n=se(r,a.returnv,{reg:t.outvar,name:t.outvarname},e);t.fnreturnf(n.type,e,n.cmnt)}else if("fn"===a.ast){let t=r.getfn(a.name);if(!t)throw M(a.pos,"uuh... this should never happen: "+t);a.inline||ce(r,e,t.real)}else if("expr"===a.ast){let t=te(r,a.expr,e);if("void"!==t.typ.type)throw M(a.pos,"unused value "+t.typ)}else if("save"===a.ast){let t=te(r,a.value,e),n=ae({reg:t.reg,name:t.cmnt},0,a.saveloc,"store",e,r);n.cmnt.out=void 0,ne(t.typ,n.type,a.pos)}else O(a);n.push(...e)}return n}function me(e){let t={},n={};e.forEach(((e,t)=>{let r=/%%{{controlflow_mark::(.+?)}}%%/.exec(e.text);r&&(n[r[1]]=t)}));let r=(r,a)=>{let s=new Set([]);return{unavailableRegisters:s,variableIsUsedLater:((r,a,s,l,i)=>{let o=new Set,p=new Set,u={},c=e=>(u[e]||(u[e]=new Set([e])),u[e]),d=e.slice(a,s).map(((e,t)=>({line:e.text,j:t+a}))),m=!1;for(;0!==d.length;){let{j:a,line:s}=d.shift(),u=/%%{{MARK_CLEAR:(.+?)}}%%/.exec(s);if(u){u[1].split(",").forEach((e=>{o.add(e),c(e).clear()}));continue}let f=/%%{{controlflow_goto::(.+?)}}%%/.exec(s);if(f){if(i[f[1]])continue;i[f[1]]=!0;let t=n[f[1]];d.unshift(...e.slice(t,a).map(((e,n)=>({line:e.text,j:n+t}))));continue}s=s.replace(/%%:((?:out\:)?)variable:(.+?):%%/g,((e,n,r)=>t[r]?"%%:"+n+"register:"+t[r]+":%%":e));let g=[...s.matchAll(/%%:register:(.+?):%%/g)].map((e=>e[1])),v=[...s.matchAll(/%%:out:register:(.+?):%%/g)].map((e=>e[1]));if(s.includes("%%:out:variable:"+r+":%%"))for(let e of g)[...c(e)].map((e=>{p.has(e)?l.add(e):p.add(e)}));else for(let e of g)[...c(e)].map((e=>l.add(e)));for(let e of v)c(e).delete(e),o.add(e);if(s.includes("%%:variable:"+r+":%%")&&(m=!0,[...o].map((e=>l.add(e)))),s.includes("%%:out:variable:"+r+":%%")){l.add("zero");for(let e of g)c(e).add(e);o.clear()}}return m})(r,a,e.length,s,{})}},a=[],s=[];return e.forEach(((e,n)=>{let l=e.text,i=l.replace(/%%:((?:out\:)?)variable:(.+?):%%/g,((e,a,i)=>{if(t[i])return"%%:register:"+t[i]+":%%";let{unavailableRegisters:o,variableIsUsedLater:p}=r(i,n),u=V.find((e=>!o.has(e)));u||(u="uu");let c=l.replace(/%%:variable:(.+?):%%/g,((e,n)=>t[n]?"%%:register:"+t[n]+":%%":e)).match(/^\s*move[\s,]+%%:out:variable:(.+?):%%[\s,]+%%:register:(.+?):%%\s*/);c&&c[1]===i&&(console.log("Wanting to save into "+c[2]),o.has(c[2])||(console.log("\\ Allowed!"),u=c[2],s[n]=!0));let d=l.match(/^\s*move[\s,]+%%:out:variable:(.+?):%%/);return d&&d[1]===i&&(p||(s[n]=!0)),t[i]=u,"%%:"+a+"register:"+u+":%%"}));a.push({text:i,comment:e.comment,indent:e.indent})})),a.filter(((e,t)=>!s[t]))}function fe(e){return e.map((e=>({text:e.text.replace(J,((e,t)=>"$"+t)),comment:e.comment,indent:e.indent}))).filter((e=>!e.text.trim().startsWith("%%{{")))}const ge=e("<div></div>"),ve=e("<pre></pre>"),ye=e('<div class="grid sm:grid-cols-2 gap-4"><div class="sm:border-r-1"><select class="border-2"><option value="readmexample.masc">Samples</option></select></div><aside class="overflow-scroll sm:border-l-1"><select class="border-2"><option value="compiled">Compiled Code</option><option value="intermediate">Intermediate Representation</option><option value="ast">AST</option><option value="parser_spec">Parser Spec</option></select><div class="relative text-sm p-4"></div></aside></div>'),xe=e("<option></option>"),he=e('<pre class="absolute bg-red-300"></pre>'),_e=new t;function be(e){const t=m.create({extensions:[f,g.of([v]),y.updateListener.of((t=>{t.docChanged&&e.onInput(t.state.doc.toString())})),_e.of(m.tabSize.of(4))]});return(()=>{const n=ge.cloneNode(!0);return(n=>{const r=new y({state:t,parent:n});l((()=>{r.update([r.state.update({changes:{from:0,to:r.state.doc.length,insert:e.initial_text}})])})),x((()=>r.destroy()))})(n),n})()}function $e(){const[e,t]=s(null),[n,a]=s(null),[m,f]=s("compiled"),[g,v]=s("readmexample.masc"),y=()=>{var e;const t=null!=(e=h[g()])?e:"Error. Invalid sample.";return"// "+(g()||"gcd")+"\n\n"+t},[x,_]=s(y());return l((()=>{_(y())})),l((()=>{var e;const n=x();console.log("effect called.");try{a(q(n,"demo.masc")),t(null)}catch(r){console.log(r),t(null!=(e=r.toString())?e:"Error. Check Console")}})),(()=>{const t=ye.cloneNode(!0),a=t.firstChild,s=a.firstChild;s.firstChild;const l=a.nextSibling.firstChild,b=l.nextSibling;return s.$$input=e=>{x()===y()||confirm("Delete edits? Ok = Delete, Cancel = Keep")?v(e.currentTarget.value):e.currentTarget.value=g()},i(s,r(o,{get each(){return Object.entries(h)},children:([e])=>(()=>{const t=xe.cloneNode(!0);return t.value=e,i(t,e),t})()}),null),i(a,r(be,{get initial_text(){return y()},onInput:e=>{console.log("text changed."),_(e)}}),null),l.$$input=e=>f(e.currentTarget.value),i(b,r(p,{get when(){return e()},children:e=>(()=>{const t=he.cloneNode(!0);return i(t,e),t})()}),null),i(b,r(c,{get children(){return[r(u,{get when(){return"compiled"===m()},get children(){const e=ve.cloneNode(!0);return i(e,(()=>{var e;return null==(e=n())?void 0:e.final})),e}}),r(u,{get when(){return"parser_spec"===m()},get children(){const e=ve.cloneNode(!0);return i(e,G),e}}),r(u,{get when(){return"intermediate"===m()},get children(){const e=ve.cloneNode(!0);return i(e,(()=>{var e;return null==(e=n())?void 0:e.intermediate.map((e=>{var t;return"    ".repeat(null!=(t=e.indent)?t:0)+e.text})).join("\n").replace(/%%{{MARK_CLEAR:(.+?)}}%%/g,"!clear $1").replace(/%%:register:(.+?):%%/g,"$$$1").replace(/%%:out:register:(.+?):%%/g,"$$$1=").replace(/%%:variable:(.+?):%%/g,"#$1").replace(/%%:out:variable:(.+?):%%/g,"#$1=").replace(/%%:(?:ref:)?label:(.+?):%%/g,"<$1>")})),e}}),r(u,{get when(){return"ast"===m()},get children(){const e=ve.cloneNode(!0);return i(e,(()=>{var e;return JSON.stringify(null==(e=n())?void 0:e.ast,((e,t)=>"pos"===e?"%<%"+(t.start.line+1)+":"+(t.start.col+1)+"-"+(t.end.line+1)+":"+(t.end.col+1)+"%>%":t),"    ").replaceAll('"%<%',"").replaceAll('%>%"',"")})),e}})]}}),null),d((e=>{const t=g(),n=m();return t!==e._v$&&(s.value=e._v$=t),n!==e._v$2&&(l.value=e._v$2=n),e}),{_v$:void 0,_v$2:void 0}),t})()}n((()=>r($e,{})),document.getElementById("app")),a(["input"]);
